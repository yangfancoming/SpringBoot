# 目录  CGLIB 示例已迁移至spring源码中
        item01： 静态代理
        item02： 静态代理 
        item03： 静态代理
        item04： 静态代理
        item07： 静态代理
        item08： JDK动态代理
        item09： JDK动态代理
        item10： JDK动态代理
        item11： CGLIB动态代理
        

# 代理模式  的 应运而生
    不使用代理开发的话  代码有两个致命的问题。
    
    1.代码混乱：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀. 
    每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点.  比如：每新添加了方法，还得继续写日志和验证
   
    2.代码分散: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 
    必须修改所有模块. 
    比如：现在此类的方法里都显示方法名，那么每个方法都得一个一个改
    
    因此 动态代理 应运而生 ！ 使用动态代理 可以拿到目标方法 从而 再目标方法执行之前/后  进行前置/后置处理 来增强方法 AOP 的典型应用。

# Java 代理模式实现方式，主要有如下五种方法
    静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。
        典型的静态代理模式一般包含三类角色:
        1.抽象角色：它的作用是定义一组行为规范。抽象角色一般呈现为接口（或抽象类），这些接口（或抽象类）中定义的方法就是待实现的。
        2.真实角色：实现了抽象角色所定义的行为。真实角色就是个普通的类，它需要实现抽象角色定义的那些接口。
        3.代理角色：代表真实角色的角色。根据上面代理的定义，我们可以知道代理角色需要至少完成（或实现）真实角色的功能。
            为了完成这一使命，那么代理角色也需要实现抽象角色所定义的行为（即代理类需要实现抽象角色所定义的接口），
            并且在实现接口方法的时候需要调用真实角色的相应方法。
    静态代理缺点： 通过上面的介绍，可以看出静态代理存在以下问题：
    1.代理类依赖于真实类，因为代理类最根本的业务功能是需要通过调用真实类来实现的。那么如果事先不知道真实类，该如何使用代理模式呢？
    2.一个真实类必须对应一个代理类，即当有多个真实类RealA、RealB、RealC...的时候，就需要多个代理类ProxyA、ProxyB、ProxyC...。这样的话如果大量使用静态代理，容易导致类的急剧膨胀。该如何解决？


    动态代理应运而生！
    JAVA动态代理与静态代理相对，静态代理是在编译期就已经确定代理类和真实类的关系，并且生成代理类的。
    而动态代理是在运行期利用JVM的反射机制生成代理类,这里是直接生成类的字节码，
    然后通过类加载器载入JAVA虚拟机执行。
    现在主流的JAVA动态代理技术的实现有两种：
        一种是JDK自带的，就是我们所说的JDK动态代理，
        另一种是开源社区的一个开源项目CGLIB


    
    基于JDK实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，实现xxx被代理接口，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。
                            (jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)
    
    基于CGlib动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术)
    
    基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）
    
    基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）

# 按照代理的创建时期，代理类可以分为两种： 静态代理 与 动态代理
    静态代理：   需要生产目标代理对象  eg: 由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。
    动态代理： 不需要生产目标代理对象  eg: 在程序运行时运用反射机制动态创建而成。
    
# JDK 动态代理 与 Cglib 动态代理
    JDK 动态代理机制只能代理实现了指定接口的类，若没有实现指定接口的类， 就不能对其实现JDK的动态代理，
    Cglib 是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。
    
    CGLIB代理和JDK代理最大的区别就是：CGLIB代理的对象不需要实现任何接口，它使用的字节码子类代理方式，但是JDK代理的对象必须实现接口
    
    JDK 动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；
    CGlib 动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；
    
    JDK 动态代理    实现 InvocationHandler 代理接口  创建动态代理类
    CGlib 动态代理  实现 MethodInterceptor 代理接口，创建动态代理类
    
    
# Cglib 动态代理
    
    Cglib 要点描述：
    代理类：继承了目标类，则在代理类中通过调用父类方法，即调用到了目标类方法。整个代理过程无需强制持有目标类的实例。
    增强器/拦截器类：实现MethodInterceptor接口的intercept方法，以达成对目标类的代理或者说功能增强（方法参数见下文：增强器/拦截器接口源码）。
    增强器/拦截器映射器：CallbackFilter。通过入参为Method类型，出参为int型增强器/拦截器数组的索引的accept方法，决定代理方法实际对应的是哪一个增强器/拦截器。（见下文：接口实现示例）
    通过Enhancer类实例，可以设置继承的目标类，传入增强器/拦截器实例组（可选），及设置增强器/拦截器映射器（可选），最终调用Enhancer#create()方法创建代理实例。
    对代理类方法的调用，实际是对增强器/拦截器组中的指定1个增强器/拦截器的intercept方法进行调用（如果没有设置增强器/拦截器，则通过super直接调用父类方法，即目标方法。不过目前还没找到能不设置的方法）
    intercept方法，一般通过代理实例上调用代理方法来反射调用到目标方法。
    
 # JDK动态代理为什么必须针对接口?
    由于java的单继承，动态生成的代理类已经继承了Proxy类的，就不能再继承其他的类，所以只能靠实现被代理类的接口的形式，故JDK的动态代理必须有接口。
    
#  为何调用代理类的方法就会自动进入InvocationHandler 的 invoke（）方法呢？
    其实是因为在动态代理类的定义中，构造函数是含参的构造，参数就是我们invocationHandler 实例，
    而每一个被代理的接口方法都会在代理类中生成一个对应的实现方法，并在实现方法中最终调用invocationHandler 的invoke方法，
    这就解释了为何执行代理类的方法会自动进入到我们自定义的invocationHandler的invoke方法中，
    然后在我们的invoke方法中再利用jdk反射的方式去调用真正的被代理类的业务方法，
    而且还可以在方法的前后去加一些我们自定义的逻辑。比如切面编程AOP等。
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 